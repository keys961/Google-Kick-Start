[![green-pi](https://img.shields.io/badge/Rendered%20with-Green%20Pi-00d571?style=flat-square)](https://github.com/nschloe/green-pi?activate&inlineMath=$)

# Kick Start 2020 G

## A: Kick_Start

> 关键词：字符串

一遍扫描，维护一个`KICK`数量`n`：

- 若扫描到`KICK`，则`n += 1`
- 若扫描到`START`，则答案`ans += n`

注意考虑`KICK`的重叠，因为它首位字母相同。

## B. Maximum Coins

> 关键词：数组

扫描并获得和最大的对角线即可。

## C. Combination Lock

> 关键词：前缀和、二分查找

首先对 $W$ 排序，可以确定最优解一定在 $W$ 中的某个位置。

我们假定最优解为 $W_{i}$ ，那么首先是判断是否需要绕过边界的问题：

1. 若 $j \lt i$ ，若要绕行则必须有 $W_{j}+N-W_{i} \le W_{i} - W_{j}$ ，即 $W_{j} \le W_{i} - \lceil \frac{N}{2} \rceil$ 

2. 若 $j \gt i$ ，若要绕行则必须有 $W_{i}-(W_{j}-N) \le W_{j} - W_{i}$ ，即 $W_{j} \ge W_{i} + \lceil \frac{N}{2} \rceil$ 

由于 $W$ 已排序，所以可以通过二分法得到上述1和2的左边界 $l$ 和右边界 $r$ ，在 $l$ 之前的和在 $r$ 之后的 $W_j$ 都需要绕过边界。

接下来计算变动次数，首先计算左边不绕过边界的次数，如下式所述：
$$
f_{1}=(W_{i}-W_{l+1})+ ...+(W_{i}-W_{i-1})= (i-l-1) \cdot W_{i} - \sum_{l+1 \le j \le i-1}{W_j} \tag{1}
$$
然后计算右边不绕过边界的次数：
$$
f_{2}=(W_{i+1}-W_{i})+...+(W_{r-1}-W_{i}) = \sum_{i+1 \le j \le r-1}{W_j} - (r-i-1) \cdot W_{i} \tag{2}
$$
然后计算左边绕过边界的次数：
$$
f_{3}=(W_{1}+n-W_{i})+ ...+(W_{l}+n-W_{i})= \sum_{1 \le j \le l}{W_j} + l \cdot (n - W_{i}) \tag{3}
$$
然后计算右边绕过边界的次数：
$$
f_{4}=(W_{i}-(W_{r}-n))+ ...+(W_{i}-(W_{w}-n))= (w-r+1) \cdot (n + W_{i})-\sum_{r \le j \le w}{W_{j}} \tag{4}
$$
上述4式中的求和项可以通过前缀和得到，所以对于某个 $W_{i}$ ，求解移动次数需要的时间复杂度为 $O(\log{W})$ 。我们对每个 $W_{i}$ 计算这样的移动次数，然后取最小值，总的时间复杂度为 $O(W\log{W})$ 。

## D. Merge Cards

> 关键词：动态规划、数学

**方法1**：最初能想到的做法就是暴力搜索，将搜索到的序列结果求和，并除以序列个数（记个数即可），即可得到答案。其时间复杂度为 $O(N!)$ ，只能过样例1。

**方法2**：其次的一种方法是动态规划分解子问题，对于某个序列 $[A_1, A_2, ..., A_n]$ 的期望，我们可以计算下面 $n-1$ 个子问题的期望，然后求和并除以 $n-1$ ，即可得到答案：

-  $[A_1+A_2, A_3, ..., A_n]$
-  $[A_1, A_2+A_3, ..., A_n]$
- ...
-  $[A_1, A_2, ..., A_{n-1}+A_n]$ 

子问题总共有 $O(N^2)$ 个，其期望可以缓存起来（动态规划），计算每个子问题需要 $O(N)$ ，所以总时间复杂度为 $O(N^3)$ ，只能过样例1和2。

**方法3**：为了过样例3，这里参考了官方的题解。

这里定义 $f(A_1, A_2, ..., A_n)$ 为序列$[A_1, A_2, ..., A_n]$ 的期望分数，根据方法2，函数的结果为：
$$
f(A_1, A_2, ..., A_n) = \frac{[A_1+A_2+f(A_1+A_2, ..., A_n)]+...+[A_{n-1}+A_{n}+f(A_1, A_2, ..., A_{n-1}+A_{n})]}{n-1}
$$
即：
$$
f(A_1, A_2, ..., A_n) = \frac{A_1+A_n}{n-1} + \sum_{2 \le i \le n-1}\lbrace{\frac{2\cdot A_i}{n-1}}\rbrace+f(A_1+A_2, ..., A_n)+...+f(A_1, A_2, ..., A_{n-1}) \tag{1}
$$
而不论 $A_i$ 的值是什么， $f(A_1, A_2, ..., A_n)$ 一定等于 $A_1$ 到 $A_n$ 的线性组合，即：
$$
f(A_1, A_2, ..., A_n)= k_{n,1}A_1+k_{n,2}A_2+...+k_{n,n}A_n \tag{2}
$$
而这里的 $k_{i,j}$ 系数实际上可以通过动态规划（记忆化搜索）算出，根据式 $(1)$ 和式 $(2)$ ，有：

- 初始下： $k_{2,1}=k_{2,2}=1$
- 边界： $k_{i,0}=0$, $k_{i,j}=0 \space (i \lt j)$
- 若 $i=1$ 或 $i=j$ ，则有 $k_{i,j} = \frac{1+(j-1) \cdot k_{i-1,j-1}+(i-j) \cdot k_{i-1,j}}{i-1}$ 
- 其他情况下： $k_{i,j} = \frac{2+(j-1) \cdot k_{i-1,j-1}+(i-j) \cdot k_{i-1,j}}{i-1}$ 

易知道计算所有的 $k_{n,j} \space (1 \le j \le n)$ 需要 $O(N^2)$ 的时间复杂度，然后代入式 $(2)$ ，即可得到答案，总时间复杂度为 $O(N^2)$ 。