[![green-pi](https://img.shields.io/badge/Rendered%20with-Green%20Pi-00d571?style=flat-square)](https://github.com/nschloe/green-pi?activate&inlineMath=$)

# Kick Start 2020 B

## A: Bike Tour

> 关键词：数组

本题只需要遍历整个数组，判断某个元素是否为peak，然后计数即可。

## B: Bus Routes

> 关键词：数组

本题需要求最晚出发的时间，并且需要保证搭乘巴士的顺序。

这里可以用一个非常简单的解法：

- 从最后向前遍历，对于最后一个元素`bus[-1]`，将其加倍到最大并不超过`D`，并修改回`bus[-1]`
- 向前遍历，对于每个`bus[i]`，将其加倍到最大并不超过`bus[i + 1]`，并修改回`bus[i]`
- 最后返回`bus[0]`

## C: Robot Path Decoding

> 关键词：栈、递归

本题标准的递归+栈题。

首先遍历字符串，使用栈构建`(`与`)`的索引位置匹配表。

然后进行解析，创建一个函数`solve(str, start, end) -> (x, y)`：

- 若遇到方位字符，则更改计数
- 若遇到数字，则记录系数`c`
- 若遇到`(`
  - 根据上面求得的匹配表，获取对应`)`的位置
  - 然后递归调用`solve`求子表达式的结果
  - 和上面的系数`c`相乘，然后累加到之前的计数上

额外注意的是处理余数。

## D. Wandering Robot

> 关键词：动态规划，排列组合

本题第一个思路就是动态规划做，这个思路非常简单，就不多说了，时间复杂度为$O(WH)$，空间复杂度为$O(W)$。但是对于本题，时间复杂度过高，会出现TLE。

所以这里考虑使用数学工具。

假如机器人要到达点$(x,y)$，那么它需要走$x+y-2$步。而所有走$x+y-2$的路径数为$2^{x+y-2}$，达到点$(x,y)$需要在$x+y-2$步中挑选$x-1$步向右走（挑选$y-1$步向下走），所以到达$(x,y)$的路径数为$C_{x+y-2}^{x-1}$。所以机器人到达点$(x,y)$的概率为：
$$
P(x,y)=\frac{C^{x-1}_{x+y-2}}{2^{x+y-2}}=\frac{(x+y-2)!}{(x-1)!(y-1)!2^{x+y-2}} \tag{x,y不是最后一行/最后一列}
$$
由于上面的分子和分母都非常大，所以可以先取对数，然后再取指数，即：
$$
P(x,y)=2^{\log_{2}{(x+y-2)!}-\log_{2}{(x-1)!}-\log_{2}{(y-1)!}-(x+y-2)} \tag{1. x,y不是最后一行/最后一列}
$$
上述带有阶乘的对数可以预处理，根据下面的递推式缓存，供后续查询：
$$
\log_{x}{n!}=\log_{x}{n}+\log_{x}{(n-1)!}
$$
而对于最后一行/最后一列的概率，需要特殊处理，因为它只能向右/向下走：
$$
P(x,H)=P(x-1,H)+0.5P(x,H-1)=\sum_{i=1}^{x}{P(i,H-1)} \tag{2. 最后一行}
$$

$$
P(W,y)=P(W,y-1)+0.5P(W-1,y)=\sum_{i=1}^{y}{P(W-1,i)} \tag{3. 最后一列}
$$

根据上面的$(1)(2)(3)$式子，就可以计算概率了。

我们首先定位被挖去矩形的左下和右上2个点，分别为$(l-1,d+1)$和$(r+1,u-1)$，然后分别沿对角线求每个点的概率，并求和即可，即下面的式子：
$$
P_{1}=\sum_{i=0}^{l-1-i\ge0, d+1+i\le H}{P(l-1-i, d+1+i)} \tag{4. 左下对角线}
$$

$$
P_{2}=\sum_{i=0}^{r+1+i \le W, u-1-i \ge 0}{P(r+1+i, u-1-i)} \tag{5. 右上对角线}
$$

$$
P=P_{1}+P_{2} \tag{6. 最终答案}
$$

可知，时间复杂度为$O(W+H)$，空间复杂度为$O(W+H)$。