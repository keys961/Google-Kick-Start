<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

# Kick Start 2020 A

## A: Allocation

> 关键词：排序

本题只要做个升序排序，然后尽可能的选择价格小的就行了。

## B: Plates

> 关键词：动态规划

本题是动态规划题，我们定义函数$f(i, j)$，它代表从前$i$碟盘子中选择$j$个，那么很明显就会有下面的递推式：
$$
f(i, j) = \max_{0 \le k \le j}{\{f(i-1,j-k) + sum(plate[:k])\}}
$$
最后我们只需要返回$f(n,p)$即可。而上面的求和函数可以预处理一下，做一个前缀和优化。

## C: Workout

> 关键词：二分查找

本题很容易就陷入一个错误的思路：不停寻找最大的间隔，然后平分。

上面的方法会有一个错误解答：考虑一个例子`[2, 12], K = 2`，假如用平分法，那么答案会是`[2, 7, 9, 12]`，最后返回`5`；而实际上最优解为`[2, 5, 8, 12]`，最后返回`4`。

所以我们倒过来思考，使用二分法，试探需要的`difficulty`是多少，而非正面直接切割以求得最佳的`difficulty`。首先我们需要求数组中相邻数字的差的最大值`max_diff`，那么`difficulty`比在`[1, max_diff]`间，我们对该区间二分查找：

- 若二分找到的值合法，则更新答案，并更新左界
- 否则更新右界

而判断`difficulty`是否有效，可以：

- 遍历数组中所有的`diff`，假如要满足`difficulty`，则需要对该`diff`切割`diff / difficulty`次，若能整除还需要减去1，我们需要累加切割的次数
- 若累加的切割次数大于`K`，则无效，否则有效

## D. Bundling

> 关键词：前缀树

我们需要将问题转化，这里有一些结论：

1. 记一个字符串集合$S$，假如有一个长度为$x$的最长公共前缀$p_x$，那么它的分数为$x$

2. 因为$p_x$是公共前缀，所以$p_1, p_2, ..., p_{x-1}$都是公共前缀，假设每个前缀贡献1分，那么总分也正好为$x$

   1. 所以某个字符串集合$S$的分数等于公共前缀的个数
   2. 问题转化为：将字符串分组，每组$S$的公共前缀个数的和最大化

3. 我们可以创建一个前缀树解决问题

   1. 每个节点记录一个计数$c$，表示所有字符串中该字符出现的次数

   2. 为了使得答案最大化，需要将该字符分布到所有的集合中，作为公共前缀的一部分，这里该字符的贡献值就是$\lfloor c/K \rfloor$，

      - $K$为集合的字符串数量

      - 多出来的余数不会被记入，因为这部分在对应集合中，并不是公共前缀

4. 所以只要遍历整个树的所有节点，对每个节点的$\lfloor c/K \rfloor$求和即可